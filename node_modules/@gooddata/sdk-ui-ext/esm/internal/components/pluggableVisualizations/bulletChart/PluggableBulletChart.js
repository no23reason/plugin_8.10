import { __assign, __extends } from "tslib";
// (C) 2019-2022 GoodData Corporation
import React from "react";
import { render } from "react-dom";
import { configurePercent, configureOverTimeComparison } from "../../../utils/bucketConfig";
import cloneDeep from "lodash/cloneDeep";
import { PluggableBaseChart } from "../baseChart/PluggableBaseChart";
import { InvalidBucketsSdkError, } from "../../../interfaces/Visualization";
import { sanitizeFilters, findDerivedBucketItem, isDerivedBucketItem, hasDerivedBucketItems, isComparisonAvailable, removeAllDerivedMeasures, getBucketItems, getAllItemsByType, } from "../../../utils/bucketHelper";
import { BUCKETS, METRIC } from "../../../constants/bucket";
import { removeSort, getCustomSortDisabledExplanation } from "../../../utils/sort";
import { getBulletChartUiConfig } from "../../../utils/uiConfigHelpers/bulletChartUiConfigHelper";
import { BULLET_CHART_CONFIG_MULTIPLE_DATES, DEFAULT_BULLET_CHART_CONFIG } from "../../../constants/uiConfig";
import { BULLET_CHART_SUPPORTED_PROPERTIES } from "../../../constants/supportedProperties";
import BulletChartConfigurationPanel from "../../configurationPanels/BulletChartConfigurationPanel";
import { getReferencePointWithSupportedProperties } from "../../../utils/propertiesHelper";
import { VisualizationTypes, getIntersectionPartAfter, BucketNames } from "@gooddata/sdk-ui";
import { bucketIsEmpty, insightBucket, newAttributeSort, } from "@gooddata/sdk-model";
import { transformBuckets } from "./bucketHelper";
import { modifyBucketsAttributesForDrillDown, addIntersectionFiltersToInsight } from "../drillDownUtil";
import { drillDownFromAttributeLocalId } from "../../../utils/ImplicitDrillDownHelper";
import { newAvailableSortsGroup } from "../../../interfaces/SortConfig";
/**
 * PluggableBulletChart
 *
 * ## Buckets
 *
 * | Name                  | Id                 | Accepts             |
 * |-----------------------|--------------------|---------------------|
 * | Measure (Primary)     | measures           | measures only       |
 * | Measure (Target)      | secondary_measures | measures only       |
 * | Measure (Comparative) | tertiary_measures  | measures only       |
 * | ViewBy                | view               | attributes or dates |
 *
 * ### Bucket axioms
 *
 * - |MeasurePrimary| = 1
 * - |MeasureTarget| ≤ 1
 * - |MeasureComparative| ≤ 1
 * - |ViewBy| ≤ 1
 *
 * ## Dimensions
 *
 * The PluggableBulletChart always creates the same two dimensional execution.
 *
 * - ⊤ ⇒ [[MeasureGroupIdentifier], [...ViewBy]]
 *
 * ## Sorts
 *
 * The PluggableBulletChart does not use any sorts.
 */
var PluggableBulletChart = /** @class */ (function (_super) {
    __extends(PluggableBulletChart, _super);
    function PluggableBulletChart(props) {
        var _this = _super.call(this, props) || this;
        _this.type = VisualizationTypes.BULLET;
        _this.supportedPropertiesList = BULLET_CHART_SUPPORTED_PROPERTIES;
        _this.initializeProperties(props.visualizationProperties);
        return _this;
    }
    PluggableBulletChart.prototype.getUiConfig = function () {
        return cloneDeep(this.isMultipleDatesEnabled() ? BULLET_CHART_CONFIG_MULTIPLE_DATES : DEFAULT_BULLET_CHART_CONFIG);
    };
    PluggableBulletChart.prototype.getExtendedReferencePoint = function (referencePoint) {
        var clonedReferencePoint = cloneDeep(referencePoint);
        var newReferencePoint = __assign(__assign({}, clonedReferencePoint), { uiConfig: this.getUiConfig() });
        var buckets = transformBuckets(newReferencePoint.buckets);
        if (!isComparisonAvailable(buckets, newReferencePoint.filters)) {
            // When in first measure bucket after transformBuckets is just one PoP measure and DataFilter is not related
            // than in configureOverTimeComparison method this measure is removed and chart stay in inconstant state
            // after 1st transformBuckets we have to check if comparison is not available and than remove all derived measures
            // from original reference point and than transform buckets again
            newReferencePoint = removeAllDerivedMeasures(newReferencePoint);
            buckets = transformBuckets(newReferencePoint.buckets);
        }
        newReferencePoint[BUCKETS] = buckets;
        newReferencePoint = getBulletChartUiConfig(newReferencePoint, this.intl, this.type);
        newReferencePoint = configurePercent(newReferencePoint, true);
        newReferencePoint = configureOverTimeComparison(newReferencePoint, !!this.featureFlags["enableWeekFilters"]);
        newReferencePoint = getReferencePointWithSupportedProperties(newReferencePoint, this.supportedPropertiesList);
        if (!this.featureFlags.enableChartsSorting) {
            newReferencePoint = removeSort(newReferencePoint);
        }
        return Promise.resolve(sanitizeFilters(newReferencePoint));
    };
    PluggableBulletChart.prototype.addFiltersForBullet = function (source, drillConfig, event) {
        var clicked = drillDownFromAttributeLocalId(drillConfig);
        var cutIntersection = getIntersectionPartAfter(event.drillContext.intersection, clicked);
        return addIntersectionFiltersToInsight(source, cutIntersection);
    };
    PluggableBulletChart.prototype.getInsightWithDrillDownApplied = function (source, drillDownContext) {
        var withFilters = this.addFiltersForBullet(source, drillDownContext.drillDefinition, drillDownContext.event);
        return modifyBucketsAttributesForDrillDown(withFilters, drillDownContext.drillDefinition);
    };
    PluggableBulletChart.prototype.renderConfigurationPanel = function (insight) {
        if (document.querySelector(this.configPanelElement)) {
            render(React.createElement(BulletChartConfigurationPanel, { locale: this.locale, references: this.references, properties: this.visualizationProperties, propertiesMeta: this.propertiesMeta, insight: insight, colors: this.colors, pushData: this.handlePushData, type: this.type, isError: this.getIsError(), isLoading: this.isLoading, featureFlags: this.featureFlags }), document.querySelector(this.configPanelElement));
        }
        return null;
    };
    PluggableBulletChart.prototype.mergeDerivedBucketItems = function (referencePoint, bucket, newDerivedBucketItems) {
        return bucket.items.reduce(function (resultItems, bucketItem) {
            resultItems.push(bucketItem);
            var newDerivedBucketItem = findDerivedBucketItem(bucketItem, newDerivedBucketItems);
            var shouldAddItem = newDerivedBucketItem &&
                !isDerivedBucketItem(bucketItem) &&
                !hasDerivedBucketItems(bucketItem, referencePoint.buckets);
            if (shouldAddItem) {
                resultItems.push(newDerivedBucketItem);
            }
            return resultItems;
        }, []);
    };
    PluggableBulletChart.prototype.checkBeforeRender = function (insight) {
        _super.prototype.checkBeforeRender.call(this, insight);
        var measureBucket = insightBucket(insight, BucketNames.MEASURES);
        if (!measureBucket || bucketIsEmpty(measureBucket)) {
            // unmount on error, AD cant recover in some scenarios
            this.unmount();
            throw new InvalidBucketsSdkError();
        }
        return true;
    };
    PluggableBulletChart.prototype.isSortDisabled = function (referencePoint) {
        var buckets = referencePoint.buckets;
        var primaryMeasures = getBucketItems(buckets, BucketNames.MEASURES);
        var viewBy = getBucketItems(buckets, BucketNames.VIEW);
        var disabledExplanation = getCustomSortDisabledExplanation(primaryMeasures, viewBy, this.intl);
        return {
            disabled: viewBy.length < 1 || primaryMeasures.length < 1,
            disabledExplanation: disabledExplanation,
        };
    };
    PluggableBulletChart.prototype.getDefaultAndAvailableSort = function (referencePoint) {
        if (this.isSortDisabled(referencePoint).disabled) {
            return {
                defaultSort: [],
                availableSorts: [],
            };
        }
        var buckets = referencePoint.buckets;
        var measures = getAllItemsByType(buckets, [METRIC]);
        var viewBy = getBucketItems(buckets, BucketNames.VIEW);
        var defaultSort = viewBy.map(function (vb) { return newAttributeSort(vb.localIdentifier, "asc"); });
        if (viewBy.length >= 2) {
            return {
                defaultSort: defaultSort,
                availableSorts: [
                    newAvailableSortsGroup(viewBy[0].localIdentifier),
                    newAvailableSortsGroup(viewBy[1].localIdentifier, measures.map(function (m) { return m.localIdentifier; }), true, measures.length > 1),
                ],
            };
        }
        if (viewBy.length === 1) {
            return {
                defaultSort: defaultSort,
                availableSorts: [
                    newAvailableSortsGroup(viewBy[0].localIdentifier, measures.map(function (m) { return m.localIdentifier; }), true, measures.length > 1),
                ],
            };
        }
        return {
            defaultSort: [],
            availableSorts: [],
        };
    };
    PluggableBulletChart.prototype.getSortConfig = function (referencePoint) {
        var _a = this.getDefaultAndAvailableSort(referencePoint), defaultSort = _a.defaultSort, availableSorts = _a.availableSorts;
        var _b = this.isSortDisabled(referencePoint), disabled = _b.disabled, disabledExplanation = _b.disabledExplanation;
        var properties = referencePoint.properties, previousAvailableSorts = referencePoint.availableSorts;
        return Promise.resolve(__assign({ supported: true, disabled: disabled, appliedSort: _super.prototype.reuseCurrentSort.call(this, previousAvailableSorts, properties, availableSorts, defaultSort), defaultSort: defaultSort,
            availableSorts: availableSorts }, (disabledExplanation && { disabledExplanation: disabledExplanation })));
    };
    return PluggableBulletChart;
}(PluggableBaseChart));
export { PluggableBulletChart };
//# sourceMappingURL=PluggableBulletChart.js.map